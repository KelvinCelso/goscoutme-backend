// File: src/@types/auth/auth.d.ts
interface SupabaseSignUpTypes {
  data: Data;
  error: null;
}

interface Data {
  user: User;
  session: Session;
}

interface Session {
  access_token: string;
  token_type: string;
  expires_in: number;
  expires_at: number;
  refresh_token: string;
  user: User;
}

interface User {
  id: string;
  aud: string;
  role: string;
  email: string;
  email_confirmed_at: string;
  phone: string;
  last_sign_in_at: string;
  app_metadata: Appmetadata;
  user_metadata: Usermetadata;
  identities: Identity[];
  created_at: string;
  updated_at: string;
  is_anonymous: boolean;
}

interface Identity {
  identity_id: string;
  id: string;
  user_id: string;
  identity_data: Usermetadata;
  provider: string;
  last_sign_in_at: string;
  created_at: string;
  updated_at: string;
  email: string;
}

interface Usermetadata {
  email: string;
  email_verified: boolean;
  phone_verified: boolean;
  sub: string;
}

interface Appmetadata {
  provider: string;
  providers: string[];
}
// File: src/@types/expresss.d.ts
// File: src/types/express.d.ts

import { UserResponse } from '@supabase/supabase-js';
import { Request } from 'express';

declare global {
  namespace Express {
    interface Request {
      user?: UserResponse; // Replace 'any' with your user type if available
    }
  }
}

// File: src/@types/options.d.ts
export enum IUserSexOptions{
  NOT_SPECIEFIED = NOT_SPECIEFIED,
  MALE = MALE,
  FEMALE = FEMALE
}

// File: src/@types/user/user.d.ts
export enum userSexOptions{
  MALE = 'MALE',
  FEMALE = 'FEMALE',
  NOT_SPECIEFIED = 'NOT_SPECIEFIED'
}
export enum CountriesOptions {
  NOT_SPECIEFIED ='NOT_SPECIEFIED',
  AFGHANISTAN = 'AFGHANISTAN',
  ALBANIA = 'ALBANIA',
  ALGERIA = 'ALGERIA',
  ANDORRA = 'ANDORRA',
  ANGOLA = 'ANGOLA',
  ANTIGUA_AND_BARBUDA = 'ANTIGUA AND BARBUDA',
  ARGENTINA = 'ARGENTINA',
  ARMENIA = 'ARMENIA',
  AUSTRALIA = 'AUSTRALIA',
  AUSTRIA = 'AUSTRIA',
  AZERBAIJAN = 'AZERBAIJAN',
  BAHAMAS = 'BAHAMAS',
  BAHRAIN = 'BAHRAIN',
  BANGLADESH = 'BANGLADESH',
  BARBADOS = 'BARBADOS',
  BELARUS = 'BELARUS',
  BELGIUM = 'BELGIUM',
  BELIZE = 'BELIZE',
  BENIN = 'BENIN',
  BHUTAN = 'BHUTAN',
  BOLIVIA = 'BOLIVIA',
  BOSNIA_AND_HERZEGOVINA = 'BOSNIA AND HERZEGOVINA',
  BOTSWANA = 'BOTSWANA',
  BRAZIL = 'BRAZIL',
  BRUNEI = 'BRUNEI',
  BULGARIA = 'BULGARIA',
  BURKINA_FASO = 'BURKINA FASO',
  BURUNDI = 'BURUNDI',
  CABO_VERDE = 'CABO VERDE',
  CAMBODIA = 'CAMBODIA',
  CAMEROON = 'CAMEROON',
  CANADA = 'CANADA',
  CENTRAL_AFRICAN_REPUBLIC = 'CENTRAL AFRICAN REPUBLIC',
  CHAD = 'CHAD',
  CHILE = 'CHILE',
  CHINA = 'CHINA',
  COLOMBIA = 'COLOMBIA',
  COMOROS = 'COMOROS',
  CONGO_DEMOCRATIC_REPUBLIC = 'CONGO, DEMOCRATIC REPUBLIC OF THE',
  CONGO_REPUBLIC = 'CONGO, REPUBLIC OF THE',
  COSTA_RICA = 'COSTA RICA',
  CROATIA = 'CROATIA',
  CUBA = 'CUBA',
  CYPRUS = 'CYPRUS',
  CZECH_REPUBLIC = 'CZECH REPUBLIC',
  DENMARK = 'DENMARK',
  DJIBOUTI = 'DJIBOUTI',
  DOMINICA = 'DOMINICA',
  DOMINICAN_REPUBLIC = 'DOMINICAN REPUBLIC',
  EAST_TIMOR = 'EAST TIMOR',
  ECUADOR = 'ECUADOR',
  EGYPT = 'EGYPT',
  EL_SALVADOR = 'EL SALVADOR',
  EQUATORIAL_GUINEA = 'EQUATORIAL GUINEA',
  ERITREA = 'ERITREA',
  ESTONIA = 'ESTONIA',
  ESWATINI = 'ESWATINI',
  ETHIOPIA = 'ETHIOPIA',
  FIJI = 'FIJI',
  FINLAND = 'FINLAND',
  FRANCE = 'FRANCE',
  GABON = 'GABON',
  GAMBIA = 'GAMBIA',
  GEORGIA = 'GEORGIA',
  GERMANY = 'GERMANY',
  GHANA = 'GHANA',
  GREECE = 'GREECE',
  GRENADA = 'GRENADA',
  GUATEMALA = 'GUATEMALA',
  GUINEA = 'GUINEA',
  GUINEA_BISSAU = 'GUINEA-BISSAU',
  GUYANA = 'GUYANA',
  HAITI = 'HAITI',
  HONDURAS = 'HONDURAS',
  HUNGARY = 'HUNGARY',
  ICELAND = 'ICELAND',
  INDIA = 'INDIA',
  INDONESIA = 'INDONESIA',
  IRAN = 'IRAN',
  IRAQ = 'IRAQ',
  IRELAND = 'IRELAND',
  ISRAEL = 'ISRAEL',
  ITALY = 'ITALY',
  IVORY_COAST = 'IVORY COAST',
  JAMAICA = 'JAMAICA',
  JAPAN = 'JAPAN',
  JORDAN = 'JORDAN',
  KAZAKHSTAN = 'KAZAKHSTAN',
  KENYA = 'KENYA',
  KIRIBATI = 'KIRIBATI',
  KOSOVO = 'KOSOVO',
  KUWAIT = 'KUWAIT',
  KYRGYZSTAN = 'KYRGYZSTAN',
  LAOS = 'LAOS',
  LATVIA = 'LATVIA',
  LEBANON = 'LEBANON',
  LESOTHO = 'LESOTHO',
  LIBERIA = 'LIBERIA',
  LIBYA = 'LIBYA',
  LIECHTENSTEIN = 'LIECHTENSTEIN',
  LITHUANIA = 'LITHUANIA',
  LUXEMBOURG = 'LUXEMBOURG',
  MADAGASCAR = 'MADAGASCAR',
  MALAWI = 'MALAWI',
  MALAYSIA = 'MALAYSIA',
  MALDIVES = 'MALDIVES',
  MALI = 'MALI',
  MALTA = 'MALTA',
  MARSHALL_ISLANDS = 'MARSHALL ISLANDS',
  MAURITANIA = 'MAURITANIA',
  MAURITIUS = 'MAURITIUS',
  MEXICO = 'MEXICO',
  MICRONESIA = 'MICRONESIA',
  MOLDOVA = 'MOLDOVA',
  MONACO = 'MONACO',
  MONGOLIA = 'MONGOLIA',
  MONTENEGRO = 'MONTENEGRO',
  MOROCCO = 'MOROCCO',
  MOZAMBIQUE = 'MOZAMBIQUE',
  MYANMAR = 'MYANMAR',
  NAMIBIA = 'NAMIBIA',
  NAURU = 'NAURU',
  NEPAL = 'NEPAL',
  NETHERLANDS = 'NETHERLANDS',
  NEW_ZEALAND = 'NEW ZEALAND',
  NICARAGUA = 'NICARAGUA',
  NIGER = 'NIGER',
  NIGERIA = 'NIGERIA',
  NORTH_KOREA = 'NORTH KOREA',
  NORTH_MACEDONIA = 'NORTH MACEDONIA',
  NORWAY = 'NORWAY',
  OMAN = 'OMAN',
  PAKISTAN = 'PAKISTAN',
  PALAU ='PALAU',
  PALESTINE = 'PALESTINE',
  PANAMA = 'PANAMA',
  PAPUA_NEW_GUINEA = 'PAPUA_NEW_GUINEA',
  PARAGUAY = 'PARAGUAY',
  PERU ='PERU',
  PHILIPPINES = 'PHILIPPINES',
  POLAND = 'POLAND',
  PORTUGAL = 'PORTUGAL',
  QATAR = 'QATAR',
  ROMANIA = 'ROMANIA',
  RUSSIA = 'RUSSIA',
  RWANDA = 'RWANDA',
  SAINT_KITTS_AND_NEVIS = 'SAINT_KITTS_AND_NEVIS',
  SAINT_LUCIA = 'SAINT_LUCIA',
  SAINT_VINCENT_AND_THE_GRENADINES = 'SAINT_VINCENT_AND_THE_GRENADINES',
  SAMOA = 'SAMOA',
  SAN_MARINO ='SAN_MARINO',
  SAO_TOME_AND_PRINCIPE = 'SAO_TOME_AND_PRINCIPE',
  SAUDI_ARABIA = 'SAUDI_ARABIA',
  SENEGAL = 'SENEGAL',
  SERBIA = 'SERBIA',
  SEYCHELLES = 'SEYCHELLES',
  SIERRA_LEONE = 'SIERRA_LEONE',
  SINGAPORE = 'SINGAPORE',
  SLOVAKIA = 'SLOVAKIA',
  SLOVENIA = 'SLOVENIA',
  SOLOMON_ISLANDS = 'SOLOMON_ISLANDS',
  SOMALIA = 'SOMALIA',
  SOUTH_AFRICA = 'SOUTH_AFRICA',
  SOUTH_KOREA = 'SOUTH_KOREA',
  SOUTH_SUDAN = 'SOUTH_SUDAN',
  SPAIN = 'SPAIN',
  SRI_LANKA = 'SRI_LANKA',
  SUDAN = 'SUDAN',
  SURINAME = 'SURINAME',
  SWEDEN = 'SWEDEN',
  SWITZERLAND = 'SWITZERLAND',
  SYRIA = 'SYRIA',
  TAIWAN = 'TAIWAN',
  TAJIKISTAN = 'TAJIKISTAN',
  TANZANIA = 'TANZANIA',
  THAILAND = 'THAILAND', 
  TOGO = 'TOGO',
  TONGA = 'TONGA',
  TRINIDAD_AND_TOBAGO = 'TRINIDAD_AND_TOBAGO',
  TUNISIA= 'TUNISIA',
  TURKEY = 'TURKEY',
  TURKMENISTAN = 'TURKMENISTAN',
  TUVALU = 'TUVALU',
  UGANDA = 'UGANDA',
  UKRAINE = 'UKRAINE',
  UNITED_ARAB_EMIRATES = 'UNITED_ARAB_EMIRATES',
  UNITED_KINGDOM = 'UNITED_KINGDOM',
  UNITED_STATES = 'UNITED_STATES',
  URUGUAY = 'URUGUAY',
  UZBEKISTAN = 'UZBEKISTAN',
  VANUATU = 'VANUATU',
  VATICAN_CITY = 'VATICAN_CITY',
  VENEZUELA = 'VENEZUELA',
  VIETNAM = 'VIETNAM',
  YEMEN = 'YEMEN',
  ZAMBIA = 'ZAMBIA',
  ZIMBABWE = 'ZIMBABWE',
}
// File: src/decorators/Security.decorator.ts
// File: src/decorators/authDecorator.ts

import { NextFunction, Request, RequestHandler, Response } from 'express';
import { isAuthenticated } from '../middlewares/authMiddleware';


export function Authenticated(): MethodDecorator {
  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const req = args[0] as Request;
      const res = args[1] as Response;
      const next = args[2] as NextFunction;

      try {
        await new Promise<void>((resolve, reject) => {
          isAuthenticated(req, res, (err: any) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
        return originalMethod.apply(this, args);
      } catch (err) {
        next(err);
      }
    };

    return descriptor;
  };
}

// File: src/decorators/controller.decorator.ts
import { MetadataKeys } from "./metadata.keys";

const Controller = (basePath: string, version?: string): ClassDecorator => {
  return (target) => {
      Reflect.defineMetadata(MetadataKeys.BASE_PATH, basePath, target);
      if (version) {
          Reflect.defineMetadata(MetadataKeys.VERSION, version, target);
      }
  };
};

export default Controller
// File: src/decorators/decoratorfactory.ts
import { Methods } from ".";
import { MetadataKeys } from "./metadata.keys";
import { Type } from "./service.decorator";
import { IRouter } from "./types";


interface MethodDecoratorOptions {
  path: string;
  requestBodyDto?: Type<any> | any;
  responseBodyDto?: Type<any> | any;
}

export const methodDecoratorFactory = (method: Methods) => {
  return (
    pathOrOptions: string | MethodDecoratorOptions,
    requestBodyDto?: Type<any> | any,
    responseBodyDto?: Type<any> | any
  ): MethodDecorator => {
    return (target, propertyKey) => {
      let path: string;
      let requestBodyDtoOption: Type<any> | any | undefined;
      let responseBodyDtoOption: Type<any> | any | undefined;

      if (typeof pathOrOptions === "string") {
        path = pathOrOptions;
        requestBodyDtoOption = requestBodyDto;
        responseBodyDtoOption = responseBodyDto;
      } else {
        path = pathOrOptions.path;
        requestBodyDtoOption = pathOrOptions.requestBodyDto;
        responseBodyDtoOption = pathOrOptions.responseBodyDto;
      }

      const controllerClass = target.constructor;
      const routers: IRouter[] =
        Reflect.hasMetadata(MetadataKeys.ROUTERS, controllerClass)
          ? Reflect.getMetadata(MetadataKeys.ROUTERS, controllerClass)
          : [];
      routers.push({
        method,
        path,
        handlerName: propertyKey,
        requestBodyDto: requestBodyDtoOption,
        responseBodyDto: responseBodyDtoOption,
      });
      Reflect.defineMetadata(MetadataKeys.ROUTERS, routers, controllerClass);
    };
  };
};
// File: src/decorators/index.ts
import { methodDecoratorFactory } from "./decoratorfactory";

import Controller from "./controller.decorator";
import { GlobalRoutes } from "./module.decorator";
import { Injectable} from "./service.decorator";
export enum Methods {
  GET = 'get',
  POST = 'post',
  PUT= 'put',
  PATCH = "patch",
  DELETE = "delete"
}
export {Controller, GlobalRoutes, Injectable};
export const Get = methodDecoratorFactory(Methods.GET);
export const Post = methodDecoratorFactory(Methods.POST);
export const Put = methodDecoratorFactory(Methods.PUT);
export const Patch = methodDecoratorFactory(Methods.PATCH);
export const Delete = methodDecoratorFactory(Methods.DELETE);
// File: src/decorators/metadata.keys.ts
export enum MetadataKeys {
  BASE_PATH = 'base_path',
  ROUTERS = 'routers',
  VERSION = "version"
}
// File: src/decorators/module.decorator.ts
import { Express } from "express";
import { MetadataKeys } from "./metadata.keys";
import { IRouter } from "./types";



export function Route(controllers: any[]): ClassDecorator {
    return function (target: any) {
        target.prototype.startModule = (app: Express) => {

            setupRoutes(app, controllers);
        };
    };
}

export function GlobalRoutes(modules: any[]): ClassDecorator {
  return function (target: any) {
      // Define a startModule method on the target class
      target.prototype.startModule = (app: Express) => {
          // Initialize each provided module
          modules.forEach(moduleClass => {
              const moduleInstance = new moduleClass();
              // Check if the module instance has a `startModule` method
              if (typeof moduleInstance.startModule === 'function') {
                  // Initialize the module, passing the Express app instance
                  moduleInstance.startModule(app);
              }
          });
      };
  };
}
export function setupRoutes(app: Express, controllers: any[]) {
  controllers.forEach(controllerClass => {

      const basePath = Reflect.getMetadata(MetadataKeys.BASE_PATH, controllerClass) || '';
      const version = Reflect.getMetadata(MetadataKeys.VERSION, controllerClass);


      const processedBasePath = basePath.startsWith('/') ? basePath : `/${basePath}`;


      let fullBasePath = processedBasePath;
      if (version) {
          fullBasePath = `/api/v${version}${processedBasePath}`;
      }


      const instance = new controllerClass();

      const routers: IRouter[] = Reflect.getMetadata(MetadataKeys.ROUTERS, controllerClass) || [];


      routers.forEach(({ method, path, handlerName }) => {

          const processedPath = path.startsWith('/') ? path : `/${path}`;

          const routePath = `${fullBasePath}${processedPath}`;

          const handler = instance[handlerName].bind(instance);

          app[method.toLowerCase()](routePath, handler);
      });
  });
}
// File: src/decorators/service.decorator.ts
import { uid } from "uid";


export interface Type<T = any> extends Function {
  new (...args: any[]): T;
}
export enum Scope {
  DEFAULT,
  TRANSIENT,
  REQUEST,
}
export interface ScopeOptions {
  scope?: Scope;
  durable?: boolean;
}
export type InjectableOptions = ScopeOptions;
export const INJECTABLE_WATERMARK = '__injectable__';
export const SCOPE_OPTIONS_METADATA = 'scope:options';
export function Injectable(options?: InjectableOptions): ClassDecorator {
  return (target: object) => {
    Reflect.defineMetadata(INJECTABLE_WATERMARK, true, target);
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA,options, target);
  };
}

export function mixin<T>(mixinClass: Type<T>) {
  Object.defineProperty(mixinClass, 'name', {
    value: uid(21),
  });
  Injectable()(mixinClass);
  return mixinClass;
}
// File: src/decorators/token.decorator.ts
import { createParamDecorator } from 'routing-controllers';
import { ForbiddenError } from 'routing-controllers';

export function Token(): ParameterDecorator {
  return createParamDecorator({
    required: true,
    value: action => {
      const token = action.request.headers['authorization']?.split(' ')[1];
      if (!token) {
        throw new ForbiddenError('Access token is missing');
      }
      return token;
    },
  });
}
// File: src/decorators/types.d.ts
export interface IRouter {
  method: Methods;
  path: string;
  handlerName: string | symbol;
  requestBodyDto?: Type<any> | any;
  responseBodyDto?: Type<any> | any;
}
// File: src/middlewares/authMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import { supabase } from '../providers/supabase/supabase';

export const isAuthenticated = async (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;

  if (!authHeader) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  const token = authHeader.split(' ')[1];
  try {
    const user = await supabase.auth.getUser(token);
    if(!user) return res.status(401).json({ message: 'Unauthorized' });
    req.user = user
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Unauthorized' });
  }
};
// File: src/middlewares/errorHandler.ts
import { BaseError, HttpStatusCode } from "../providers/errorProvider";
import { NextFunction, Request, Response } from "express";

export function errorHandler(
  err,
  req: Request,
  res: Response,
  next: NextFunction
) {
  console.error(err);

  if (err instanceof BaseError) {
    res.status(err.httpCode).json({
      error: err.name,
      message: err.message,
    });
  } else {
    res.status(HttpStatusCode.INTERNAL_SERVER).json({
      error: "INTERNAL SERVER ERROR",
      message: "An unexpected error occurred",
    });
  }
}

// Register the error handler as the last middleware
// File: src/modules.ts
import { Express } from "express";
import { GlobalRoutes } from "./decorators";
import { AuthController } from "./useCases/Auth/auth.controller";
import { AuthRoutes } from "./useCases/Auth/auth.route";
import { ProfileRoutes } from "./useCases/Profile/profile.route";
import { SportsRoutes } from "./useCases/Sports/sports.route";
import { MediaRoutes } from "./useCases/Media/Media.route";
import { AppointmentsRoutes } from "./useCases/Appointments/appointments.route";

@GlobalRoutes([AuthRoutes, ProfileRoutes, SportsRoutes, MediaRoutes, AppointmentsRoutes])
export class AppGlobalRoutes {
  startModule(app: Express): void {}
}



// File: src/providers/errorProvider.ts
export enum HttpStatusCode {
  OK = 200,
  BAD_REQUEST = 400,
  NOT_FOUND = 404,
  INTERNAL_SERVER = 500,
  FORBIDDEN = 403,
  UNAUTORIZED = 401,
}

export class BaseError extends Error {
  public readonly name: string;
  public readonly httpCode: HttpStatusCode;
  public readonly isOperational: boolean;

  constructor(
    name: string,
    httpCode: HttpStatusCode,
    isOperational: boolean,
    description: string
  ) {
    super(description);
    Object.setPrototypeOf(this, new.target.prototype);

    this.name = name;
    this.httpCode = httpCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this);
  }
}

export class APIError extends BaseError {
  constructor(
    name,
    httpCode = HttpStatusCode.INTERNAL_SERVER,
    isOperational = true,
    description = "internal server error"
  ) {
    super(name, httpCode, isOperational, description);
  }
}

class HTTP404Error extends BaseError {
  constructor(description) {
    super("NOT FOUND", HttpStatusCode.NOT_FOUND, true, description);
  }
}
// File: src/providers/prisma/prismaClient.ts
import { PrismaClient as Prisma } from "@prisma/client";


export class PrismaService {
  public readonly client: Prisma; 

  constructor() {
    this.client = new Prisma();
  }

  async close() {
    await this.client.$disconnect();
  }
}
// File: src/providers/redis/redisClient.ts
import { Redis } from 'ioredis';
import { Server } from 'socket.io';

export class RedisService {
  private readonly cacheClient: Redis;
  private readonly pubClient: Redis;
  private readonly subClient: Redis;
  // private schoolGateway: SchoolGateway;
  private readonly subscribers: { [channel: string]: Server[] } = {};
  constructor() {
    this.cacheClient = new Redis(process.env.REDIS_URL);
    this.pubClient = new Redis(process.env.REDIS_URL);
    this.subClient = new Redis(process.env.REDIS_URL);

    this.cacheClient.on('error', (err) => {
      console.log('Error on Redis cache client');
      console.log(err);
      process.exit(1);
    });

    this.pubClient.on('error', (err) => {
      console.log('Error on Redis Pub/Sub client');
      console.log(err);
      process.exit(1);
    });
    this.subClient.on('error', (err) => {
      console.log('Error on Redis Pub/Sub client');
      console.log(err);
      process.exit(1);
    });

    this.cacheClient.on('connect', () => {
      console.log('Redis cache client connected');
    });

    this.pubClient.on('connect', () => {
      console.log('Redis Pub/Sub client connected');
    });
    this.subClient.on('connect', () => {
      console.log('Redis Pub/Sub client connected');
    });

    this.subClient.on('message', (channel: string, message: string) => {
      if (this.subscribers[channel]) {
        for (const server of this.subscribers[channel]) {
          server.emit(channel, message);
        }
      }
    });
  }

  // Redis caching methods

  async get(key: string) {
    return await this.cacheClient.get(key);
  }

  async set(key: string, value: string, mode?: string, duration?: number) {
    if (mode === 'EX' && duration) {
      return await this.cacheClient.set(key, value, mode, duration);
    }
    return await this.cacheClient.set(key, value);
  }

  // Redis Pub/Sub methods

  async subscribe(channel: string, server: Server, duration?: number) {
    if (!this.subscribers[channel]) {
      this.subscribers[channel] = [];
      console.log(this.subscribers, "created")
      await this.subClient.subscribe(channel);
    }
    if(this.subscribers[channel].find((s)=> server)){
      return;
    }else{
      return this.subscribers[channel].push(server);
    }
  }

  async publish(channel: string, message: string) {
    return await this.pubClient.publish(channel, message);
  }

  async unsubscribe(channel: string, server: Server) {
    if (this.subscribers[channel]) {
      const index = this.subscribers[channel].indexOf(server);
      if (index !== -1) {
        this.subscribers[channel].splice(index, 1);
        if (this.subscribers[channel].length === 0) {
          delete this.subscribers[channel];
          return await this.subClient.unsubscribe(channel);
        }
      }
    }
  }
}
// File: src/providers/s3/s3Client.ts
import { S3Client } from "@aws-sdk/client-s3";

export class S3Provider{
  public client: S3Client
  public r2: S3Client
   constructor(){
    this.client = new S3Client({
      region: 'af-south-1',
      credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_KEY_ID
    },

  })
   }
   
}
// File: src/providers/supabase/supabase.ts
import { createClient } from '@supabase/supabase-js'
export const supabase = createClient('https://mkroqhhzgdfcinnephdx.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1rcm9xaGh6Z2RmY2lubmVwaGR4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MTczMzY4NTYsImV4cCI6MjAzMjkxMjg1Nn0.nLGB3XDH3cuh3C3ixIBWfoAN6nGS0yQUggaOEnaIh0Q')
// File: src/providers/webSocket/webSocket.ts
import { Server as HTTPServer } from "http";
import { Socket, Server } from "socket.io";
import { v4 } from "uuid";
import { RedisService } from "../redis/redisClient";

interface IJoinData {
  user_id: string;
}

export class ServerSocket  extends RedisService{
  public static instance: ServerSocket;
  public io: Server;
  private readonly redis: RedisService;

  public users: { [uid: string]: Socket };

  constructor(server: HTTPServer) {
    super()
    ServerSocket.instance = this;
    this.users = {};
    this.io = new Server(server, {
      serveClient: false,
      pingInterval: 10000,
      pingTimeout: 5000,
      cookie: false,
      cors: {
        origin: "*",
      },
    });
    this.redis = new RedisService()
    this.io.on("connection", this.startListeners);
    console.info("Socket IO started");
  }
  startListeners = (socket: Socket) => {
  };
  public async unsubscribeUser(user: string){
    await this.redis.unsubscribe(user, this.io);
  }
  public async subscribeUser(user: string, duration: number){
    await this.redis.subscribe(user, this.io, duration);
  }

}
// File: src/server.ts
import express, { NextFunction, Request, Response, Router } from "express";
import "express-async-errors";
import 'reflect-metadata';
import * as dotenv from "dotenv";
import * as http from "http";
import cors from "cors";
import { AppGlobalRoutes } from "./modules";
import { errorHandler } from "./middlewares/errorHandler";
import { RedisService } from "./providers/redis/redisClient";
import { createServer } from 'http';
import { Server, Socket } from "socket.io";
import { ServerSocket } from "./providers/webSocket/webSocket";


dotenv.config();
const app = express();
const server = createServer(app);

const port = process.env.PORT || 3000;
const appGlobalRoutesInstance = new AppGlobalRoutes();


app.use(express.json());
app.use(cors());
appGlobalRoutesInstance.startModule(app);


app.use(errorHandler);

const socket = new ServerSocket(server)
server.listen(port);

export { app, server, socket };
// File: src/useCases/Appointments/appointments.controller.ts
import { Controller, Post, Get, Put, Delete } from "../../decorators";
import { NextFunction, Request, Response } from "express";
import { CreateAppointmentsDto, UpdateAppointmentsDto } from "./dto";
import { Authenticated } from "../../decorators/Security.decorator";
import { AppointmentsUseCase } from "./appointments.service";

@Controller('/appointments', '1')
export class AppointmentsController {
  @Authenticated()
  @Post("/create")
  async handleCreateappointments(request: Request<{}, {}, CreateAppointmentsDto>, response: Response, next: NextFunction) {
    try{  
      const user = request.user.data.user.id
      const data = await new AppointmentsUseCase().executeCreateAppointments(user, request.body)
      return response.status(201).json(data)
    }catch(err){
      next(err)
    }
  }

  @Authenticated()
  @Get("/get_user_appointments")
  async handleReadAppointments(request: Request, response: Response, next: NextFunction) {
    try{  
      const user = request.user.data.user.id
      const data = await new AppointmentsUseCase().executeReadAppointments(user)
      return response.status(200).json(data)
    }catch(err){
      next(err)
    }
  }

  @Put("/:id")
  async handleUpdateAppointments(request: Request<{id: string}, {}, UpdateAppointmentsDto>, response: Response) {
    // Handle updating a resource by ID
    return response.json({ message: "Update appointments" });
  }

  @Delete("/:id")
  async handleDeleteAppointments(request: Request<{id: string}>, response: Response) {
    // Handle deleting a resource by ID
    return response.json({ message: "Delete appointments" });
  }
}

// File: src/useCases/Appointments/appointments.route.ts
import { Route } from "../../decorators/module.decorator";
import { AppointmentsController } from "./appointments.controller";

@Route([AppointmentsController])
export class AppointmentsRoutes {
  // Add route logic here if needed
}

// File: src/useCases/Appointments/appointments.service.ts
import { NotFoundError } from "routing-controllers";
import { PrismaService } from "../../providers/prisma/prismaClient";
import { CreateAppointmentsDto } from "./dto";
import { RedisService } from "../../providers/redis/redisClient";
import { ServerSocket } from "../../providers/webSocket/webSocket";
import { socket } from "../../server";

class AppointmentsUseCase {
  private readonly prisma: PrismaService
  private readonly redis: RedisService
  constructor(){
    this.prisma = new PrismaService();
    this.redis = new RedisService();
  }
  async executeCreateAppointments(scout_id: string, dto: CreateAppointmentsDto) {
    console.log(scout_id)
    const scout = await this.prisma.client.userScoutProfile.findFirst({
      where: {
        profile: {
          public_id: scout_id
        }
      }
    })
    if(!scout) throw new NotFoundError('there is no scout with the provided id')
    const athlete = await this.prisma.client.userAthleteProfile.findFirst({
      where: {
        profile: {
          public_id: String(dto.athlete_id)
        }
      }
  })  
    if(!athlete) throw new NotFoundError('there is no athlete with the provided id')
    await socket.subscribeUser(String(dto.athlete_id), 30)
    const appointments = await this.prisma.client.userAppointments.create({
      data: {
        scout_id: scout.id, 
        athlete_id: athlete.id,
        scheduled: new Date(dto.scheduled).toISOString(),
        description: dto.description,
        duration: dto.duration,
        title: dto.title
      }
    }) 
    
    await socket.publish(String(dto.athlete_id), JSON.stringify(appointments))
    return appointments
  }

  async executeReadAppointments(id: string) {
      const appointments = await this.prisma.client.userAppointments.findMany({
        include: {
          athlete: {
            include: {
              profile: {
                include: {
                  sport: true,
                }
              }
            }
          },
          scout: {
          }
        },
        where: {
          OR: [
            {
              athlete: {
                profile: {
                  public_id: id
                }
              },
            },
            {
              scout: {
                profile: {
                  public_id: id
                }
              }
            }
          ]
        }
      })  
      return appointments
  }

  async executeUpdateAppointments() {
    // Implement the update use case logic here
  }

  async executeDeleteAppointments() {
    // Implement the delete use case logic here
  }
}

export { AppointmentsUseCase };

// File: src/useCases/Appointments/dto/CreateAppointments.dto.ts
import { UserAppointments } from '@prisma/client';
import { IsNotEmpty, IsString } from 'class-validator';

export type CreateAppointmentsDto = Omit<UserAppointments,'scout_id'>

// File: src/useCases/Appointments/dto/UpdateAppointments.dto.ts
import { CreateAppointmentsDto } from "./CreateAppointments.dto";

type CreateAppointmentsDtoPartial = Partial<CreateAppointmentsDto>
export class UpdateAppointmentsDto implements CreateAppointmentsDtoPartial {}

// File: src/useCases/Appointments/dto/index.ts
import { CreateAppointmentsDto } from "./CreateAppointments.dto";
import { UpdateAppointmentsDto } from "./UpdateAppointments.dto";

export { CreateAppointmentsDto, UpdateAppointmentsDto }

// File: src/useCases/Auth/auth.controller.ts
import { Controller, Post, Get, Put, Delete } from "../../decorators";
import { NextFunction, Request, Response } from "express";
import { ICreateAuthDto, UpdateAuthDto } from "./dto";
import { AuthUseCase } from "./auth.service";
import { ISignIn } from "./dto/CreateAuth.dto";
import { Token } from "../../decorators/token.decorator";

@Controller('auth', '1')
export class AuthController {
  @Post("sign_up")
  async handleCreateauth(request: Request<{}, {}, ICreateAuthDto>, response: Response, next: NextFunction) {
    try{
      const data = await new AuthUseCase().executeSignUp(request.body)
      return response.json(data);
    }catch(err){
      next(err);
    }
  }

  @Post("sign_in")
  async handleSignIn(request: Request<{}, {}, ISignIn>, response: Response, next: NextFunction) {
    try{
      const data = await new AuthUseCase().executeSignIn(request.body)
      return response.json(data);
    }catch(err){
      next(err);
    }
  }


 

  @Get("/refresh_token")
  async handleRefreshToken(request: Request<{id: string}>, response: Response,next: NextFunction, @Token() token: string) {
    try{
      const data = await new AuthUseCase().executeRefreshToken(token)
      return response.status(200).json(data);
    }catch(err){
      next(err);
    }
  }
}

// File: src/useCases/Auth/auth.route.ts
import { Route } from "../../decorators/module.decorator";
import { AuthController } from "./auth.controller";

@Route([AuthController])
export class AuthRoutes {
  // Add route logic here if needed
}

// File: src/useCases/Auth/auth.service.ts
import { AuthResponse, SignUpWithPasswordCredentials } from "@supabase/supabase-js";
import { supabase } from "../../providers/supabase/supabase";
import { ICreateAuthDto, ISignIn } from "./dto/CreateAuth.dto";
import { BaseError, HttpStatusCode } from "../../providers/errorProvider";
import { PrismaService } from "../../providers/prisma/prismaClient";

class AuthUseCase {
  private readonly prisma: PrismaService
  constructor(){
    this.prisma = new PrismaService();
  }
  async executeSignUp(dto:ICreateAuthDto) {
    const user: AuthResponse = await supabase.auth.signUp({
      options: {
        data: {
          firstName: dto.email,
          lastName: dto.last_name
        }
      },
      email: dto.email,
      password: dto.password
    })
    if(user.error) throw new BaseError('FORBIDDEN', HttpStatusCode.FORBIDDEN, true, 'User already exists')
    delete user.data.user.user_metadata,
    delete user.data.user.identities
    return {
      session: user.data.session,
      user: user.data.user,
    }
  }

  async executeSignIn(dto: ISignIn) {
    const user: AuthResponse = await supabase.auth.signInWithPassword({
      email: dto.email,
      password: dto.password
    })
    if(!user.data.user) throw new BaseError('FORBIDDEN', HttpStatusCode.FORBIDDEN, true, 'email or password is incorret')
    const user_profile = await this.prisma.client.profiles.findUnique({
      include: {
        sport: true,
        athlete: true,
        scout: true,
        organization: true
      },
      where: {
        public_id: user.data.user.id
      }
    })
    delete user.data.user.user_metadata,
    delete user.data.user.identities
    return {
      profile: user_profile,
      session: user.data.session,
      user: user.data.user
    }
  }


  async executeRefreshToken(refresh_token: string) {
    const {data, error} = await supabase.auth.refreshSession({refresh_token: refresh_token})
    if(error) throw new BaseError(error.code, error.status, false, error.message)
    return data
  }

  async getCurrentUser(access_token: string){
    const {data, error} = await supabase.auth.getUser(access_token)
    if(error) throw new BaseError(error.code, error.status, false, error.message)
    const profile = await this.prisma.client.profiles.findUnique({
      where: {
        public_id: data.user.id
      }
    })
    if(error) throw new BaseError(error.code, error.status, false, error.message)

    return{
      profile: profile,
      user: data.user
    }
  }
}

export { AuthUseCase };

// File: src/useCases/Auth/dto/CreateAuth.dto.ts
import { UserSexOptions, CountriesOptions } from '@prisma/client';
import { IsDateString, IsEmail, IsEnum, IsMobilePhone, IsNotEmpty, IsOptional, IsPhoneNumber, IsString } from 'class-validator';


export class ICreateAuthDto {
  @IsString()
  first_name: string;

  @IsString()
  last_name: string;

  @IsEmail()
  email: string;

  @IsString()
  password: string;

  @IsString()
  age: number;

  @IsEnum(UserSexOptions)
  sex: UserSexOptions
  
  @IsEnum(CountriesOptions)
  nationality: CountriesOptions;

  @IsEnum(CountriesOptions)
  citzenship: CountriesOptions;

  @IsDateString()
  date: Date;

  @IsOptional()
  @IsPhoneNumber()
  phone?: string

  @IsOptional()
  @IsMobilePhone()
  mobile?: string

  @IsOptional()
  @IsString()
  address?: string
}

export class ISignIn{
  @IsEmail()
  email: string;
  @IsString()
  password: string;
}
// File: src/useCases/Auth/dto/UpdateAuth.dto.ts
import { ICreateAuthDto } from "./CreateAuth.dto";

type CreateAuthDtoPartial = Partial<ICreateAuthDto>
export class UpdateAuthDto implements CreateAuthDtoPartial {}

// File: src/useCases/Auth/dto/index.ts
import { ICreateAuthDto } from "./CreateAuth.dto";
import { UpdateAuthDto } from "./UpdateAuth.dto";

export { ICreateAuthDto, UpdateAuthDto }

// File: src/useCases/Media/Media.controller.ts
import { Controller, Post, Get, Put, Delete } from "../../decorators";
import { NextFunction, Request, Response } from "express";
import { CreateMediaDto, UpdateMediaDto } from "./dto";
import { Authenticated } from "../../decorators/Security.decorator";
import { MediaUseCase } from "./Media.service";

@Controller('/Media', '1')
export class MediaController {
  @Authenticated()
  @Post("/storeMedia")
  async handleCreateMedia(request: Request<{}, {}, CreateMediaDto>, response: Response, next: NextFunction){
    try{
      const user_id = request.user.data.user.id
      const media = await new MediaUseCase().executeCreateMedia(request.body, user_id)
      return response.status(201).json(media);
    }catch(err){
      next(err)
    }
  }

  @Authenticated()
  @Post("/create_presigned_url")
  async handleCreatePresignedUrl(request: Request, response: Response, next: NextFunction) {
    try{
      const {file_name, file_type} = request.body
      const user_id = request.user.data.user.id
      const presignedUrl = await new MediaUseCase().executeCreatePresignedUser(user_id,file_name, file_type)
      return response.status(201).json({url:presignedUrl});
    }catch(err){
      next(err)
    }
  }

  @Authenticated()
  @Get("/get")
  async handleReadMedia(request: Request, response: Response, next: NextFunction) {
    try{
      const {athlete_id} = request.query
      const presignedUrl = await new MediaUseCase().executeReadMedia(Number(athlete_id))
      return response.status(201).json({url:presignedUrl});
    }catch(err){
      next(err)
    }
  }

  @Put("/:id")
  async handleUpdateMedia(request: Request<{id: string}, {}, UpdateMediaDto>, response: Response) {
    // Handle updating a resource by ID
    return response.json({ message: "Update Media" });
  }

  @Delete("/:id")
  async handleDeleteMedia(request: Request<{id: string}>, response: Response) {
    // Handle deleting a resource by ID
    return response.json({ message: "Delete Media" });
  }
}

// File: src/useCases/Media/Media.route.ts
import { Route } from "../../decorators/module.decorator";
import { MediaController } from "./Media.controller";

@Route([MediaController])
export class MediaRoutes {
  // Add route logic here if needed
}

// File: src/useCases/Media/Media.service.ts
import { NotFoundError } from "routing-controllers";
import { PrismaService } from "../../providers/prisma/prismaClient";
import { CreateMedia } from "./dto/CreateMedia.dto";
import { HttpStatusCode } from "../../providers/errorProvider";
import { supabase } from "../../providers/supabase/supabase";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { S3Provider } from "../../providers/s3/s3Client";
import { PutObjectAclCommand, PutObjectCommand } from "@aws-sdk/client-s3";

class MediaUseCase {
  private readonly prisma: PrismaService
  private readonly s3: S3Provider
  constructor(){
    this.prisma = new PrismaService();
    this.s3 = new S3Provider();
  }
  async executeCreateMedia(dto: CreateMedia, user_id: string) {
    const user = await this.prisma.client.userAthleteProfile.findFirst({
      where: {
        profile: {
          public_id: user_id
        }
      }
    })
    if(!user) throw new NotFoundError('user was not found')
    const file = await this.prisma.client.userMedia.create({
      data: {
        athlete_id: user.id,
        media_url: `https://goscoutmee.s3.af-south-1.amazonaws.com/${user.id}/${dto.name.replace(
          / /g,
          '+',
        )}`,
        type: dto.type,
        name: dto.name
      }
    })
    return file
  }

  async executeCreatePresignedUser(user_id: string, file_name: string, file_type: string){
    const signedUrl = await getSignedUrl(this.s3.client,new PutObjectCommand({
      Bucket: 'goscoutmee',
      Key: `${user_id}/${file_name}`,
      ACL: 'public-read-write'
    }), {expiresIn: 600})
    return signedUrl
  }

  async executeReadMedia(athlete_id: number) {
    const media = await this.prisma.client.userMedia.findMany({
      where: {
        athlete_id: athlete_id
      }
    })
    return media
  }

  async executeUpdateMedia() {
    // Implement the update use case logic here
  }

  async executeDeleteMedia() {
    // Implement the delete use case logic here
  }
}

export { MediaUseCase };

// File: src/useCases/Media/dto/CreateMedia.dto.ts
import { UserMedia } from '@prisma/client';
import { IsNotEmpty, IsString } from 'class-validator';

export type CreateMedia =  UserMedia
// File: src/useCases/Media/dto/UpdateMedia.dto.ts
import { CreateMediaDto } from "./CreateMedia.dto";

type CreateMediaDtoPartial = Partial<CreateMediaDto>
export class UpdateMediaDto implements CreateMediaDtoPartial {}

// File: src/useCases/Media/dto/index.ts
import { CreateMediaDto } from "./CreateMedia.dto";
import { UpdateMediaDto } from "./UpdateMedia.dto";

export { CreateMediaDto, UpdateMediaDto }

// File: src/useCases/Notifications/dto/CreateNotifications.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateNotificationsDto {

  // Add other properties as needed
}

// File: src/useCases/Notifications/dto/UpdateNotifications.dto.ts
import { CreateNotificationsDto } from "./CreateNotifications.dto";

type CreateNotificationsDtoPartial = Partial<CreateNotificationsDto>
export class UpdateNotificationsDto implements CreateNotificationsDtoPartial {}

// File: src/useCases/Notifications/dto/index.ts
import { CreateNotificationsDto } from "./CreateNotifications.dto";
import { UpdateNotificationsDto } from "./UpdateNotifications.dto";

export { CreateNotificationsDto, UpdateNotificationsDto }

// File: src/useCases/Notifications/notifications.controller.ts
import { Controller, Post, Get, Put, Delete } from "../../decorators";
import { Request, Response } from "express";
import { CreateNotificationsDto, UpdateNotificationsDto } from "./dto";

@Controller('/notifications', '1')
export class NotificationsController {
  @Post("")
  async handleCreatenotifications(request: Request<{}, {}, CreateNotificationsDto>, response: Response) {
    // Handle creation of a new resource
    return response.json({ message: "Create notifications" });
  }

  @Get("")
  async handleReadNotifications(request: Request, response: Response) {
    // Handle reading a resource
    return response.json({ message: "Read notifications" });
  }

  @Put("/:id")
  async handleUpdateNotifications(request: Request<{id: string}, {}, UpdateNotificationsDto>, response: Response) {
    // Handle updating a resource by ID
    return response.json({ message: "Update notifications" });
  }

  @Delete("/:id")
  async handleDeleteNotifications(request: Request<{id: string}>, response: Response) {
    // Handle deleting a resource by ID
    return response.json({ message: "Delete notifications" });
  }
}

// File: src/useCases/Notifications/notifications.route.ts
import { Route } from "../../decorators/module.decorator";
import { NotificationsController } from "./notifications.controller";

@Route([NotificationsController])
export class NotificationsRoutes {
  // Add route logic here if needed
}

// File: src/useCases/Notifications/notifications.service.ts
class NotificationsUseCase {
  async executeSubscribeUser(user_id) {

  }

  async executeReadNotifications() {
    // Implement the read use case logic here
  }

  async executeUpdateNotifications() {
    // Implement the update use case logic here
  }

  async executeDeleteNotifications() {
    // Implement the delete use case logic here
  }
}

export { NotificationsUseCase };

// File: src/useCases/Profile/dto/CreateProfile.dto.ts
import { UserSexOptions, CountriesOptions, Profiles, UserAthleteProfile, UserScoutProfile, UserOrganization, UserCareerStatistics } from '@prisma/client';
import { IsDateString, IsEmail, IsEnum, IsMobilePhone, IsNotEmpty, IsOptional, IsPhoneNumber, IsString } from 'class-validator';


export type ICreateProfileDto = Profiles & UserAthleteProfile & UserScoutProfile & UserOrganization & UserCareerStatistics &{
  userType: 'ATHLETE' | 'SCOUT'
}
// File: src/useCases/Profile/dto/UpdateProfile.dto.ts
import { ICreateProfileDto } from "./CreateProfile.dto";

export type UpdateProfileDto = Partial<ICreateProfileDto>


// File: src/useCases/Profile/dto/index.ts
import { ICreateProfileDto } from "./CreateProfile.dto";
import { UpdateProfileDto } from "./UpdateProfile.dto";

export { ICreateProfileDto, UpdateProfileDto }


// File: src/useCases/Profile/profile.controller.ts
import { Controller, Post, Get, Put, Delete } from "../../decorators";
import { NextFunction, Request, Response } from "express";
import { ICreateProfileDto, UpdateProfileDto } from "./dto";
import { ProfileUseCase } from "./profile.service";
import { Authenticated} from "../../decorators/Security.decorator";
import { supabase } from "../../providers/supabase/supabase";
import { BaseError, HttpStatusCode } from "../../providers/errorProvider";
import { AthleteStatusOptions, CountriesOptions, UserSexOptions } from "@prisma/client";

@Controller('/profile', '1')
export class ProfileController {
  @Authenticated()
  @Post("/create_profile")
  async handleCreateprofile(request: Request<{}, {}, ICreateProfileDto>, response: Response, next: NextFunction) {
    try{
      const user_id = request.user.data.user.id
      const data = await new ProfileUseCase().executeCreateProfile(request.body, user_id)
      return response.json(data);
    }catch(err){
      next(err)
    }
  }
  
  @Get("/get_athletes")
  @Authenticated()
  async handleFilterAthletes(request: Request, response: Response, next: NextFunction) {
    try {
      const { sex, ageMin, ageMax, status, country, page, items, position, id } = request.query;
      const data = await new ProfileUseCase().filterAthletes({
        sex: sex as UserSexOptions,
        id: id as string,
        positions: position as string,
        ageMin: parseInt(ageMin as string),
        ageMax: parseInt(ageMax as string),
        status: status as AthleteStatusOptions,
        country: country as CountriesOptions,
        page: parseInt(page as string),
        items: parseInt(items as string)
      });
      return response.json(data);
    } catch (err) {
      next(err);
    }
  }

  @Get("/get_all_athletes")
  @Authenticated()
  async handleReadAthletes(request: Request, response: Response, next: NextFunction) {
    try{
      const { page, items } = request.query;
      const data = await new ProfileUseCase().executeReadAthletes(parseInt(page as string), parseInt(items as string))
      return response.json(data);
    }catch(err) {
      next(err);
    }
  }
  @Get("/get_athlete_by_id")
  @Authenticated()
  async handleReadAthlete(request: Request<{},{}, {}, {id: string}>, response: Response, next: NextFunction) {
    try{
      const {id} = request.query;
      const data = await new ProfileUseCase().executeReadAthlete(id)
      return response.json(data);
    }catch(err) {
      next(err);
    }
  }


  @Put("/update_profile/")
  @Authenticated()
  async handleUpdateProfile(request: Request<{id: string}, {}, UpdateProfileDto>, response: Response) {
    const user = request.user
    const data = await new ProfileUseCase().executeUpdateProfile(user.data.user.id, request.body )
    return response.json(data);
  }

}

// File: src/useCases/Profile/profile.route.ts
import { Route } from "../../decorators/module.decorator";
import { ProfileController } from "./profile.controller";

@Route([ProfileController])
export class ProfileRoutes {
  // Add route logic here if needed
}

// File: src/useCases/Profile/profile.service.ts
import { AthleteStatusOptions } from "@prisma/client";
import { BaseError, HttpStatusCode } from "../../providers/errorProvider";
import { PrismaService } from "../../providers/prisma/prismaClient";
import { ICreateProfileDto, UpdateProfileDto } from "./dto";
import { IFilterAthletesParams } from "./types";


class ProfileUseCase {
  private readonly prisma: PrismaService
  constructor(){
    this.prisma = new PrismaService();
  }
  async executeCreateProfile(dto: ICreateProfileDto, user_id: string) {
    await this.validateUser(dto)
    const profile = await this.prisma.client.profiles.create({
      include: {
        sport: true,
        organization: true
      },
      data: {
        first_name: dto.first_name,
        last_name: dto.last_name,
        email: dto.email,
        birth_date: new Date(dto.birth_date).toISOString(),
        sex: dto.sex,
        affiliations: dto.affiliations || null,
        address: dto.address ? dto.address : null,
        mobile: dto.mobile ? dto.mobile : null,
        phone: dto.phone ? dto.phone : null,
        organization: {
          create: {
            org_document_url: dto.org_document_url || null,
            org_email: dto.org_email,
            org_mobile: dto.org_mobile ||null,
            org_name: dto.org_name|| null,
            org_phone: dto.org_phone || null
          }
        },
        nationality: dto.nationality,
        public_id:user_id,
        sport_id: dto.sport_id,
      }
    })
    if(dto.userType === 'ATHLETE'){
      const athlete = await this.prisma.client.userAthleteProfile.create({
        data: {
          age: dto.age,
          height: dto.height,
          weight: dto.weight,
          profile_id: profile.id,
          citzenship: dto.citzenship,
          height_metric: dto.height_metric,
          weight_metric: dto.weight_metric,
          career_statistics: {
            create: {
              game_appearances: dto.game_appearances || 0,
              minutes_played: dto.minutes_played || 0,
              field_goals: dto.field_goals || 0,
              game_started: dto.game_started || 0,
            }
          },
          sport_position_id: dto.sport_position_id,
          status: dto.status || AthleteStatusOptions.NOT_SPECIEFIED,
        }
      })
      return{
        profile: profile,
        athlete: athlete
      }
    }else {
      const scout = await this.prisma.client.userScoutProfile.create({
        data: {
          profile_id: profile.id,
        }
      })
      return{
        profile: profile,
        scout: scout
      }
    }
  }

  async executeReadAthletes(page: number, items:number) {
    const athlete = await this.prisma.client.userAthleteProfile.findMany({
      skip: page * items,
      take: items,
      include: {
        profile: {include: {sport: true}},
        sport_position: true
      
      }
    })
    if(!athlete) throw new BaseError('NOT FOUND',404, false,'there are no athlete users in the database')
    return [...athlete]
  }
  async executeReadAthlete(public_id: string) {
    const athlete = await this.prisma.client.userAthleteProfile.findFirst({
      include: {
        profile: {
          include: {
            organization: true
          },
        },
        sport_position: true,
        media: true,
      },
      where: {
        profile: {
          public_id
        }
      }
    })
    if(!athlete) throw new BaseError('NOT FOUND',404, false,'there are no athlete users in the database')
    return athlete
  }

  async filterAthletes(params: IFilterAthletesParams) {
    const whereClause: any = {
      profile: {}
    };
    const positionQuery = this.stringToNumberArray(params.positions)
    const sexQuery = this.stringToStringArray(params.sex)
    const statusQuery = this.stringToStringArray(params.status)
    const countryQuery = this.stringToStringArray(params.country)
    if(params.id) whereClause.profile.public_id = { contains: params.id}
    if(positionQuery && positionQuery.length > 0) whereClause.sport_position_id = whereClause.sport_position_id = { in: positionQuery};
    if (sexQuery && sexQuery.length > 0) whereClause.profile.sex = whereClause.profile.sex = {in: sexQuery};
    if (params.ageMin ) whereClause.age = { gte: params.ageMin };
    if (params.ageMax) whereClause.age = { lte: params.ageMax };
    if (statusQuery && statusQuery.length > 0) whereClause.status = whereClause.status = {in: statusQuery};
    if (countryQuery && countryQuery.length > 0) whereClause.profile.nationality = whereClause.profile.nationality = {in: countryQuery};
    const athletes = await this.prisma.client.userAthleteProfile.findMany({
      skip: params.page * params.items,
      take: params.items,
      where: Object.keys(whereClause).length > 0 ? whereClause : undefined,
      include: {
        profile: {
          include: {
            organization: true
          }
        },
        sport_position: true
      },
    });

    return athletes;
  }
  async executeUpdateProfile(id: string, dto: UpdateProfileDto) {
    const profile = await this.prisma.client.profiles.update({
      where: { public_id: id },
      data: {
        ...dto
      }
    });
    return profile;
  }


  private async validateUser(dto: ICreateProfileDto){
    if(!dto.userType ) throw new BaseError('BAD REQUEST', HttpStatusCode.BAD_REQUEST, false, 'Error creating profile')
    if(dto.userType === 'ATHLETE' ){
      if(!dto.height || !dto.height|| !dto.weight || !dto.weight_metric 
        || !dto.citzenship || !dto.status || !dto.age  || !dto.sport_position_id
       )throw new BaseError('BAD REQUEST', HttpStatusCode.BAD_REQUEST, false, 'could not create athlete profile ')
       return;
     }
  }
  private stringToNumberArray(text: string){
    if(!text) return []
    const data = text.split('-');
    const values = []
    for (let i =0; i<= data.length; i++){
      if(Number(data[i])){
        values.push(Number(data[i]))
      }
    }
    return values
  }
  private stringToStringArray(text: string){
    if(!text) return []
    const data = text.split('-');
    const values = []
    for (let i =0; i<= data.length; i++){
      if(data[i]){
        values.push(data[i])
      }
    }
    return values
  }
}





export { ProfileUseCase };

// File: src/useCases/Profile/types/index.d.ts
export interface IFilterAthletesParams {
  sex?: UserSexOptions;
  positions?: string ;
  ageMin?: number;
  ageMax?: number;
  status?: AthleteStatusOptions;
  country?: CountriesOptions;
  page: number;
  items?: number;
  id?: string
}
// File: src/useCases/Sports/dto/CreateSports.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class CreateSportsDto {

  // Add other properties as needed
}

// File: src/useCases/Sports/dto/UpdateSports.dto.ts
import { CreateSportsDto } from "./CreateSports.dto";

type CreateSportsDtoPartial = Partial<CreateSportsDto>
export class UpdateSportsDto implements CreateSportsDtoPartial {}

// File: src/useCases/Sports/dto/index.ts
import { CreateSportsDto } from "./CreateSports.dto";
import { UpdateSportsDto } from "./UpdateSports.dto";

export { CreateSportsDto, UpdateSportsDto }

// File: src/useCases/Sports/sports.controller.ts
import { Controller, Post, Get, Put, Delete } from "../../decorators";
import { NextFunction, Request, Response } from "express";
import { CreateSportsDto, UpdateSportsDto } from "./dto";
import { SportsUseCase } from "./sports.service";

@Controller('/sports', '1')
export class SportsController {


  @Get("/get_sports_position")
  async handleReadSports(request: Request, response: Response, next: NextFunction) {
    try{
      const {sport_id} = request.query
      const data = await new SportsUseCase().executeReadSportsPositions(Number(sport_id))
      response.status(200).json(data)
    }catch(err){
      next(err)
    }

  }
}

// File: src/useCases/Sports/sports.route.ts
import { Route } from "../../decorators/module.decorator";
import { SportsController } from "./sports.controller";

@Route([SportsController])
export class SportsRoutes {
  // Add route logic here if needed
}

// File: src/useCases/Sports/sports.service.ts
import { PrismaService } from "../../providers/prisma/prismaClient";

class SportsUseCase {
  private readonly prisma: PrismaService
  constructor(){
    this.prisma = new PrismaService();
  }
  async executeReadSportsPositions(sport_id: number) {
    const sportsPositions = await this.prisma.client.sportPosition.findMany({
      where: {
        sport_id: sport_id
      }
    })
    return sportsPositions
  }
}

export { SportsUseCase };

// File: prisma/migrations/20240608111849_new_migration/migration.sql
-- CreateEnum
CREATE TYPE "UserSexOptions" AS ENUM ('NOT_SPECIEFIED', 'MALE', 'FEMALE');

-- CreateEnum
CREATE TYPE "CountriesOptions" AS ENUM ('NOT_SPECIEFIED', 'AFGHANISTAN', 'ALBANIA', 'ALGERIA', 'ANDORRA', 'ANGOLA', 'ANTIGUA_AND_BARBUDA', 'ARGENTINA', 'ARMENIA', 'AUSTRALIA', 'AUSTRIA', 'AZERBAIJAN', 'BAHAMAS', 'BAHRAIN', 'BANGLADESH', 'BARBADOS', 'BELARUS', 'BELGIUM', 'BELIZE', 'BENIN', 'BHUTAN', 'BOLIVIA', 'BOSNIA_AND_HERZEGOVINA', 'BOTSWANA', 'BRAZIL', 'BRUNEI', 'BULGARIA', 'BURKINA_FASO', 'BURUNDI', 'CABO_VERDE', 'CAMBODIA', 'CAMEROON', 'CANADA', 'CENTRAL_AFRICAN_REPUBLIC', 'CHAD', 'CHILE', 'CHINA', 'COLOMBIA', 'COMOROS', 'CONGO_DEMOCRATIC_REPUBLIC', 'CONGO_REPUBLIC', 'COSTA_RICA', 'CROATIA', 'CUBA', 'CYPRUS', 'CZECH_REPUBLIC', 'DENMARK', 'DJIBOUTI', 'DOMINICA', 'DOMINICAN_REPUBLIC', 'EAST_TIMOR', 'ECUADOR', 'EGYPT', 'EL_SALVADOR', 'EQUATORIAL_GUINEA', 'ERITREA', 'ESTONIA', 'ESWATINI', 'ETHIOPIA', 'FIJI', 'FINLAND', 'FRANCE', 'GABON', 'GAMBIA', 'GEORGIA', 'GERMANY', 'GHANA', 'GREECE', 'GRENADA', 'GUATEMALA', 'GUINEA', 'GUINEA_BISSAU', 'GUYANA', 'HAITI', 'HONDURAS', 'HUNGARY', 'ICELAND', 'INDIA', 'INDONESIA', 'IRAN', 'IRAQ', 'IRELAND', 'ISRAEL', 'ITALY', 'IVORY_COAST', 'JAMAICA', 'JAPAN', 'JORDAN', 'KAZAKHSTAN', 'KENYA', 'KIRIBATI', 'KOSOVO', 'KUWAIT', 'KYRGYZSTAN', 'LAOS', 'LATVIA', 'LEBANON', 'LESOTHO', 'LIBERIA', 'LIBYA', 'LIECHTENSTEIN', 'LITHUANIA', 'LUXEMBOURG', 'MADAGASCAR', 'MALAWI', 'MALAYSIA', 'MALDIVES', 'MALI', 'MALTA', 'MARSHALL_ISLANDS', 'MAURITANIA', 'MAURITIUS', 'MEXICO', 'MICRONESIA', 'MOLDOVA', 'MONACO', 'MONGOLIA', 'MONTENEGRO', 'MOROCCO', 'MOZAMBIQUE', 'MYANMAR', 'NAMIBIA', 'NAURU', 'NEPAL', 'NETHERLANDS', 'NEW_ZEALAND', 'NICARAGUA', 'NIGER', 'NIGERIA', 'NORTH_KOREA', 'NORTH_MACEDONIA', 'NORWAY', 'OMAN', 'PAKISTAN', 'PALAU', 'PALESTINE', 'PANAMA', 'PAPUA_NEW_GUINEA', 'PARAGUAY', 'PERU', 'PHILIPPINES', 'POLAND', 'PORTUGAL', 'QATAR', 'ROMANIA', 'RUSSIA', 'RWANDA', 'SAINT_KITTS_AND_NEVIS', 'SAINT_LUCIA', 'SAINT_VINCENT_AND_THE_GRENADINES', 'SAMOA', 'SAN_MARINO', 'SAO_TOME_AND_PRINCIPE', 'SAUDI_ARABIA', 'SENEGAL', 'SERBIA', 'SEYCHELLES', 'SIERRA_LEONE', 'SINGAPORE', 'SLOVAKIA', 'SLOVENIA', 'SOLOMON_ISLANDS', 'SOMALIA', 'SOUTH_AFRICA', 'SOUTH_KOREA', 'SOUTH_SUDAN', 'SPAIN', 'SRI_LANKA', 'SUDAN', 'SURINAME', 'SWEDEN', 'SWITZERLAND', 'SYRIA', 'TAIWAN', 'TAJIKISTAN', 'TANZANIA', 'THAILAND', 'TOGO', 'TONGA', 'TRINIDAD_AND_TOBAGO', 'TUNISIA', 'TURKEY', 'TURKMENISTAN', 'TUVALU', 'UGANDA', 'UKRAINE', 'UNITED_ARAB_EMIRATES', 'UNITED_KINGDOM', 'UNITED_STATES', 'URUGUAY', 'UZBEKISTAN', 'VANUATU', 'VATICAN_CITY', 'VENEZUELA', 'VIETNAM', 'YEMEN', 'ZAMBIA', 'ZIMBABWE');

-- CreateEnum
CREATE TYPE "MediaOptions" AS ENUM ('VIDEO', 'IMAGE');

-- CreateEnum
CREATE TYPE "HeightOptions" AS ENUM ('CM', 'FT');

-- CreateEnum
CREATE TYPE "WeightOptions" AS ENUM ('KG', 'LB');

-- CreateEnum
CREATE TYPE "AthleteStatusOptions" AS ENUM ('NOT_SPECIEFIED', 'PROFESSIONAL', 'AMATEUR');

-- CreateEnum
CREATE TYPE "UserAccountStatusOptions" AS ENUM ('ACTIVE', 'INATIVE');

-- CreateTable
CREATE TABLE "Profiles" (
    "id" SERIAL NOT NULL,
    "public_id" TEXT NOT NULL,
    "first_name" TEXT NOT NULL,
    "last_name" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "sex" "UserSexOptions" NOT NULL DEFAULT 'NOT_SPECIEFIED',
    "birth_date" TIMESTAMP(3) NOT NULL,
    "account_status" "UserAccountStatusOptions" NOT NULL DEFAULT 'INATIVE',
    "nationality" "CountriesOptions" NOT NULL DEFAULT 'NOT_SPECIEFIED',
    "sport_id" INTEGER NOT NULL,
    "phone" TEXT,
    "mobile" TEXT,
    "affiliations" TEXT,
    "address" TEXT,

    CONSTRAINT "Profiles_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserAthleteProfile" (
    "id" SERIAL NOT NULL,
    "profile_id" INTEGER NOT NULL,
    "citzenship" "CountriesOptions"[] DEFAULT ARRAY['NOT_SPECIEFIED']::"CountriesOptions"[],
    "age" INTEGER NOT NULL,
    "height" DOUBLE PRECISION NOT NULL,
    "height_metric" "HeightOptions" NOT NULL DEFAULT 'CM',
    "weight" DOUBLE PRECISION NOT NULL,
    "weight_metric" "WeightOptions" NOT NULL DEFAULT 'KG',
    "status" "AthleteStatusOptions" NOT NULL DEFAULT 'NOT_SPECIEFIED',
    "leagues_played" TEXT,
    "sport_position_id" INTEGER,
    "league_played" TEXT,

    CONSTRAINT "UserAthleteProfile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserCareerStatistics" (
    "id" SERIAL NOT NULL,
    "athlete_id" INTEGER NOT NULL,
    "game_appearances" INTEGER NOT NULL DEFAULT 0,
    "minutes_played" INTEGER NOT NULL DEFAULT 0,
    "game_started" INTEGER NOT NULL DEFAULT 0,
    "field_goals" INTEGER NOT NULL DEFAULT 0,
    "attribute_update_at" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "UserCareerStatistics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserSportsAttributes" (
    "athlete_id" INTEGER NOT NULL,
    "sport_attributes_id" INTEGER NOT NULL,

    CONSTRAINT "UserSportsAttributes_pkey" PRIMARY KEY ("athlete_id","sport_attributes_id")
);

-- CreateTable
CREATE TABLE "SportPosition" (
    "id" INTEGER NOT NULL,
    "sport_id" INTEGER NOT NULL,
    "name" TEXT NOT NULL
);

-- CreateTable
CREATE TABLE "UserScoutProfile" (
    "id" SERIAL NOT NULL,
    "profile_id" INTEGER NOT NULL,

    CONSTRAINT "UserScoutProfile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserGuardian" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "relationship" TEXT NOT NULL,
    "profile_id" INTEGER NOT NULL,
    "consent_form" TEXT NOT NULL,

    CONSTRAINT "UserGuardian_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Sports" (
    "id" SERIAL NOT NULL,
    "public_id" TEXT NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "Sports_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SportsAttributes" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "sport_id" INTEGER NOT NULL,

    CONSTRAINT "SportsAttributes_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserOrganization" (
    "id" SERIAL NOT NULL,
    "org_name" TEXT,
    "org_email" TEXT,
    "org_phone" TEXT,
    "org_mobile" TEXT,
    "org_document_url" TEXT,
    "profile_id" INTEGER NOT NULL,

    CONSTRAINT "UserOrganization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserMedia" (
    "id" SERIAL NOT NULL,
    "athlete_id" INTEGER NOT NULL,
    "name" TEXT NOT NULL,
    "type" "MediaOptions" NOT NULL,
    "media_url" TEXT NOT NULL,

    CONSTRAINT "UserMedia_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserAppointments" (
    "athlete_id" INTEGER NOT NULL,
    "scout_id" INTEGER NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "duration" TEXT NOT NULL,
    "scheduled" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "UserAppointments_pkey" PRIMARY KEY ("athlete_id","scout_id","scheduled")
);

-- CreateIndex
CREATE UNIQUE INDEX "Profiles_public_id_key" ON "Profiles"("public_id");

-- CreateIndex
CREATE UNIQUE INDEX "UserAthleteProfile_profile_id_key" ON "UserAthleteProfile"("profile_id");

-- CreateIndex
CREATE UNIQUE INDEX "UserCareerStatistics_athlete_id_key" ON "UserCareerStatistics"("athlete_id");

-- CreateIndex
CREATE UNIQUE INDEX "SportPosition_id_key" ON "SportPosition"("id");

-- CreateIndex
CREATE UNIQUE INDEX "UserScoutProfile_profile_id_key" ON "UserScoutProfile"("profile_id");

-- CreateIndex
CREATE UNIQUE INDEX "Sports_public_id_key" ON "Sports"("public_id");

-- CreateIndex
CREATE UNIQUE INDEX "UserOrganization_profile_id_key" ON "UserOrganization"("profile_id");

-- AddForeignKey
ALTER TABLE "Profiles" ADD CONSTRAINT "Profiles_sport_id_fkey" FOREIGN KEY ("sport_id") REFERENCES "Sports"("id") ON DELETE NO ACTION ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserAthleteProfile" ADD CONSTRAINT "UserAthleteProfile_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "Profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserAthleteProfile" ADD CONSTRAINT "UserAthleteProfile_sport_position_id_fkey" FOREIGN KEY ("sport_position_id") REFERENCES "SportPosition"("id") ON DELETE NO ACTION ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserCareerStatistics" ADD CONSTRAINT "UserCareerStatistics_athlete_id_fkey" FOREIGN KEY ("athlete_id") REFERENCES "UserAthleteProfile"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserSportsAttributes" ADD CONSTRAINT "UserSportsAttributes_athlete_id_fkey" FOREIGN KEY ("athlete_id") REFERENCES "UserAthleteProfile"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserSportsAttributes" ADD CONSTRAINT "UserSportsAttributes_sport_attributes_id_fkey" FOREIGN KEY ("sport_attributes_id") REFERENCES "SportsAttributes"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SportPosition" ADD CONSTRAINT "SportPosition_sport_id_fkey" FOREIGN KEY ("sport_id") REFERENCES "Sports"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserScoutProfile" ADD CONSTRAINT "UserScoutProfile_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "Profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserGuardian" ADD CONSTRAINT "UserGuardian_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "UserAthleteProfile"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SportsAttributes" ADD CONSTRAINT "SportsAttributes_sport_id_fkey" FOREIGN KEY ("sport_id") REFERENCES "Sports"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserOrganization" ADD CONSTRAINT "UserOrganization_profile_id_fkey" FOREIGN KEY ("profile_id") REFERENCES "Profiles"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserMedia" ADD CONSTRAINT "UserMedia_athlete_id_fkey" FOREIGN KEY ("athlete_id") REFERENCES "UserAthleteProfile"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserAppointments" ADD CONSTRAINT "UserAppointments_athlete_id_fkey" FOREIGN KEY ("athlete_id") REFERENCES "UserAthleteProfile"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserAppointments" ADD CONSTRAINT "UserAppointments_scout_id_fkey" FOREIGN KEY ("scout_id") REFERENCES "UserScoutProfile"("id") ON DELETE CASCADE ON UPDATE CASCADE;

// File: prisma/migrations/20240609001232_new_migration/migration.sql
/*
  Warnings:

  - A unique constraint covering the columns `[email]` on the table `Profiles` will be added. If there are existing duplicate values, this will fail.

*/
-- CreateIndex
CREATE UNIQUE INDEX "Profiles_email_key" ON "Profiles"("email");

// File: prisma/migrations/migration_lock.toml
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
// File: prisma/schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "darwin-arm64", "linux-musl-arm64-openssl-3.0.x", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Profiles {
  id             Int                      @id @default(autoincrement())
  public_id      String                   @unique
  first_name     String
  last_name      String
  email          String                   @unique
  sex            UserSexOptions           @default(NOT_SPECIEFIED)
  birth_date     DateTime
  account_status UserAccountStatusOptions @default(INATIVE)
  nationality    CountriesOptions         @default(NOT_SPECIEFIED)
  sport_id       Int
  phone          String?
  mobile         String?
  organization   UserOrganization?
  affiliations   String?
  address        String?
  sport          Sports?                  @relation(fields: [sport_id], references: [id], onDelete: NoAction)
  athlete        UserAthleteProfile?
  scout          UserScoutProfile?
}

model UserAthleteProfile {
  id                Int                    @id @default(autoincrement())
  profile_id        Int                    @unique
  profile           Profiles               @relation(fields: [profile_id], references: [id], onDelete: Cascade)
  citzenship        CountriesOptions[]     @default([NOT_SPECIEFIED])
  age               Int
  height            Float
  height_metric     HeightOptions          @default(CM)
  weight            Float
  weight_metric     WeightOptions          @default(KG)
  status            AthleteStatusOptions   @default(NOT_SPECIEFIED)
  leagues_played    String?
  guardians         UserGuardian[]
  appointmenst      UserAppointments[]
  media             UserMedia[]
  career_statistics UserCareerStatistics?
  sport_position_id Int?
  league_played     String?
  sport_position    SportPosition?         @relation(fields: [sport_position_id], references: [id], onDelete: NoAction)
  sport_attributes  UserSportsAttributes[]
}

model UserCareerStatistics {
  id                  Int                @id @default(autoincrement())
  athlete_id          Int                @unique
  athlete             UserAthleteProfile @relation(fields: [athlete_id], references: [id], onDelete: Cascade)
  game_appearances    Int                @default(0)
  minutes_played      Int                @default(0)
  game_started        Int                @default(0)
  field_goals         Int                @default(0)
  attribute_update_at DateTime           @updatedAt
}

model UserSportsAttributes {
  athlete_id          Int
  athlete             UserAthleteProfile @relation(fields: [athlete_id], references: [id])
  attributes          SportsAttributes   @relation(fields: [sport_attributes_id], references: [id])
  sport_attributes_id Int

  @@id([athlete_id, sport_attributes_id])
}

model SportPosition {
  id       Int                  @unique
  sport_id Int
  sport    Sports               @relation(fields: [sport_id], references: [id])
  name     String
  athlete  UserAthleteProfile[]
}

model UserScoutProfile {
  id           Int                @id @default(autoincrement())
  profile_id   Int                @unique
  profile      Profiles           @relation(fields: [profile_id], references: [id], onDelete: Cascade)
  appointments UserAppointments[]
}

model UserGuardian {
  id           Int                @id @default(autoincrement())
  name         String
  relationship String
  profile_id   Int
  profile      UserAthleteProfile @relation(fields: [profile_id], references: [id], onDelete: Cascade)
  consent_form String
}

model Sports {
  id             Int                @id @default(autoincrement())
  public_id      String             @unique @default(uuid())
  name           String
  attibutes      SportsAttributes[]
  sport_position SportPosition[]
  user           Profiles[]
}

model SportsAttributes {
  id       Int                    @id @default(autoincrement())
  name     String
  sport_id Int
  sport    Sports                 @relation(fields: [sport_id], references: [id], onDelete: Cascade)
  athlete  UserSportsAttributes[]
}

model UserOrganization {
  id               Int      @id @default(autoincrement())
  org_name         String?
  org_email        String?
  org_phone        String?
  org_mobile       String?
  org_document_url String?
  profile_id       Int      @unique
  profile          Profiles @relation(fields: [profile_id], references: [id], onDelete: Cascade)
}

model UserMedia {
  id         Int                @id @default(autoincrement())
  athlete_id Int
  athlete    UserAthleteProfile @relation(fields: [athlete_id], references: [id], onDelete: Cascade)
  name       String
  type       MediaOptions
  media_url  String
}

model UserAppointments {
  athlete_id  Int
  scout_id    Int
  title       String
  description String
  duration    String
  scheduled   DateTime
  athlete     UserAthleteProfile @relation(fields: [athlete_id], references: [id], onDelete: Cascade)
  scout       UserScoutProfile   @relation(fields: [scout_id], references: [id], onDelete: Cascade)

  @@id([athlete_id, scout_id, scheduled])
}

enum UserSexOptions {
  NOT_SPECIEFIED
  MALE
  FEMALE
}

enum CountriesOptions {
  NOT_SPECIEFIED
  AFGHANISTAN
  ALBANIA
  ALGERIA
  ANDORRA
  ANGOLA
  ANTIGUA_AND_BARBUDA
  ARGENTINA
  ARMENIA
  AUSTRALIA
  AUSTRIA
  AZERBAIJAN
  BAHAMAS
  BAHRAIN
  BANGLADESH
  BARBADOS
  BELARUS
  BELGIUM
  BELIZE
  BENIN
  BHUTAN
  BOLIVIA
  BOSNIA_AND_HERZEGOVINA
  BOTSWANA
  BRAZIL
  BRUNEI
  BULGARIA
  BURKINA_FASO
  BURUNDI
  CABO_VERDE
  CAMBODIA
  CAMEROON
  CANADA
  CENTRAL_AFRICAN_REPUBLIC
  CHAD
  CHILE
  CHINA
  COLOMBIA
  COMOROS
  CONGO_DEMOCRATIC_REPUBLIC
  CONGO_REPUBLIC
  COSTA_RICA
  CROATIA
  CUBA
  CYPRUS
  CZECH_REPUBLIC
  DENMARK
  DJIBOUTI
  DOMINICA
  DOMINICAN_REPUBLIC
  EAST_TIMOR
  ECUADOR
  EGYPT
  EL_SALVADOR
  EQUATORIAL_GUINEA
  ERITREA
  ESTONIA
  ESWATINI
  ETHIOPIA
  FIJI
  FINLAND
  FRANCE
  GABON
  GAMBIA
  GEORGIA
  GERMANY
  GHANA
  GREECE
  GRENADA
  GUATEMALA
  GUINEA
  GUINEA_BISSAU
  GUYANA
  HAITI
  HONDURAS
  HUNGARY
  ICELAND
  INDIA
  INDONESIA
  IRAN
  IRAQ
  IRELAND
  ISRAEL
  ITALY
  IVORY_COAST
  JAMAICA
  JAPAN
  JORDAN
  KAZAKHSTAN
  KENYA
  KIRIBATI
  KOSOVO
  KUWAIT
  KYRGYZSTAN
  LAOS
  LATVIA
  LEBANON
  LESOTHO
  LIBERIA
  LIBYA
  LIECHTENSTEIN
  LITHUANIA
  LUXEMBOURG
  MADAGASCAR
  MALAWI
  MALAYSIA
  MALDIVES
  MALI
  MALTA
  MARSHALL_ISLANDS
  MAURITANIA
  MAURITIUS
  MEXICO
  MICRONESIA
  MOLDOVA
  MONACO
  MONGOLIA
  MONTENEGRO
  MOROCCO
  MOZAMBIQUE
  MYANMAR
  NAMIBIA
  NAURU
  NEPAL
  NETHERLANDS
  NEW_ZEALAND
  NICARAGUA
  NIGER
  NIGERIA
  NORTH_KOREA
  NORTH_MACEDONIA
  NORWAY
  OMAN
  PAKISTAN
  PALAU
  PALESTINE
  PANAMA
  PAPUA_NEW_GUINEA
  PARAGUAY
  PERU
  PHILIPPINES
  POLAND
  PORTUGAL
  QATAR
  ROMANIA
  RUSSIA
  RWANDA
  SAINT_KITTS_AND_NEVIS
  SAINT_LUCIA
  SAINT_VINCENT_AND_THE_GRENADINES
  SAMOA
  SAN_MARINO
  SAO_TOME_AND_PRINCIPE
  SAUDI_ARABIA
  SENEGAL
  SERBIA
  SEYCHELLES
  SIERRA_LEONE
  SINGAPORE
  SLOVAKIA
  SLOVENIA
  SOLOMON_ISLANDS
  SOMALIA
  SOUTH_AFRICA
  SOUTH_KOREA
  SOUTH_SUDAN
  SPAIN
  SRI_LANKA
  SUDAN
  SURINAME
  SWEDEN
  SWITZERLAND
  SYRIA
  TAIWAN
  TAJIKISTAN
  TANZANIA
  THAILAND
  TOGO
  TONGA
  TRINIDAD_AND_TOBAGO
  TUNISIA
  TURKEY
  TURKMENISTAN
  TUVALU
  UGANDA
  UKRAINE
  UNITED_ARAB_EMIRATES
  UNITED_KINGDOM
  UNITED_STATES
  URUGUAY
  UZBEKISTAN
  VANUATU
  VATICAN_CITY
  VENEZUELA
  VIETNAM
  YEMEN
  ZAMBIA
  ZIMBABWE
}

enum MediaOptions {
  VIDEO
  IMAGE
}

enum HeightOptions {
  CM
  FT
}

enum WeightOptions {
  KG
  LB
}

enum AthleteStatusOptions {
  NOT_SPECIEFIED
  PROFESSIONAL
  AMATEUR
}

enum UserAccountStatusOptions {
  ACTIVE
  INATIVE
}

